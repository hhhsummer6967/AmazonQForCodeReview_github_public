### 3.6 测试

- **单元测试规范**
  - 测试类的命名，一般以测试的类+Test，如：CalculatorTest
  - 测试方法的命名，一般以test开头+测试的方法，如testAdd
  - 单测行覆盖率一般要求大于75%
  - 单测包含主流程用例、参数边界值等校验用例
  - 单测包含中间件访问超时、返回空等异常的用例
  - 单测用例包含并发、防重、幂等等用例
  - 测试应独立且可重复
  - 测试应快速执行

- **集成测试**
  - 测试组件间交互
  - 测试外部依赖
  - 测试系统整体功能

- **边界条件测试**
  - 测试最小/最大值
  - 测试空值/null
  - 测试特殊字符
  - 测试格式错误的输入

- **异常路径测试**
  - 测试异常情况
  - 测试错误处理
  - 测试资源不可用情况
  - 测试超时情况

### 3.7 日志与监控

- **日志打印规范**
  - 日志级别选择正确（error、warn、info、debug）
  - 日志打印调用方法的入参和响应结果，尤其是跨系统调用
  - 业务日志包含关键参数，如userId、bizSeq等，便于问题排查
  - 敏感信息进行脱敏处理
  - 不符合预期的情况，如未知异常或特殊场景，打印相关日志
  - 避免过多的日志输出，影响性能和可读性

- **监控与告警**
  - 关键业务流程有监控指标
  - 系统性能有监控指标
  - 异常情况有告警机制
  - 数据库慢SQL有监控

### 3.8 可维护性与可扩展性

- **模块化设计**
  - 代码适当模块化
  - 模块之间低耦合
  - 模块内部高内聚
  - 定义清晰的接口
  - 避免循环依赖

- **可扩展性**
  - 代码易于扩展
  - 使用适当的设计模式
  - 考虑未来可能的变化
  - 避免过度设计
  - 接口设计具有可扩展性

- **代码坏味道识别**
  - 大量重复代码（抽公用方法，设计模式）
  - 方法参数过多（可封装成一个DTO对象）
  - 方法过长（抽小函数）
  - 判断条件太多（优化if...else）
  - 不处理没用的代码（没用的import）
  - 避免过度设计

## 4. 特定场景检查点

### 4.1 并发控制规范

- 在使用并发集合时，注意线程安全性和并发性能，如ConcurrentHashMap是线程安全的，HashMap是非线程安全的
- 乐观锁、悲观锁防止数据库并发。乐观锁一般用版本号version控制，悲观锁一般用select ...for update
- 单实例的多线程并发处理，一般通过Java锁机制，比如synchronized、ReentrantLock
- 同一集群的多线程并发处理，可以用Redis分布式锁或者zookeeper
- 跨集群的多线程并发处理，则考虑数据库实现的分布式锁
- 使用分布式锁时，注意潜在问题，如Redis的一些经典问题

### 4.2 事务控制规范

- 推荐使用编程式事务，而非@Transactional注解的声明式事务
- 事务范围要明确，数据库操作必须在事务作用范围内
- 非数据库操作尽量不要包含在事务内
- 不要在事务内进行远程调用（可能导致数据不一致）
- 事务中避免处理太多数据，查询相关操作尽量放到事务之外

### 4.3 幂等处理规范

- 接口设计考虑幂等性
- 实现幂等的常见方法：唯一索引、状态机、分布式锁、token机制等
- 对关键业务操作实现幂等处理
- 幂等实现要考虑并发情况

### 4.4 远程调用规范

- 不要把超时当作失败处理，应发起查询确认是否成功
- 异常处理：捕获并处理远程调用可能抛出的异常
- 网络安全：考虑数据加密、认证、访问控制等
- 服务质量：避免过度使用远程调用、优化数据传输、实现负载均衡等
- 版本兼容：注意服务端和客户端之间的版本兼容性
- 尽量避免for循环远程调用，应考虑实现批量功能的接口
